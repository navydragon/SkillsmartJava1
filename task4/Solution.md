task4 — Три кита ООП (часть 2)
================================================================

4.1. Композиция двух иерархий
-----------------------------
- Добавлена иерархия экипажа: абстрактный `CrewMember` и его потомки `Pilot`, `Engineer`.
- Имеющаяся иерархия транспорта (`Vehicle → Spaceship → {ExplorerShip, CourierShip}`) теперь компонуется с иерархией экипажа в классе `Expedition`.
- `Expedition` агрегирует объект миссии `Mission`, флагман (`Spaceship`) и список `CrewMember`. В методах `printManifest()` и `launch()` видно, что все составляющие живут внутри экспедиции, но остаются полноценными объектами своих иерархий.

4.2. Полиморфизм подтипов и метод `foo()`
----------------------------------------
- В родительском `Spaceship` добавлен метод `foo()`, который переопределён в `ExplorerShip` и `CourierShip`. Каждая реализация выводит свой текст (название класса, дополнительные параметры).
- В `Main.demonstrateSubtypePolymorphism()` формируется массив из 500 элементов `Spaceship`, случайно набранных из исследовательских и курьерских кораблей. Цикл вызывает `foo()` «вслепую».
- **Почему вывод именно такой?** JVM во время выполнения смотрит на реальный тип объекта в ячейке массива (`ExplorerShip` или `CourierShip`) и динамически выбирает соответствующую реализацию `foo()`. Поэтому сообщения чередуются в точности в зависимости от фактического типа каждого элемента, несмотря на то что мы работаем с массивом базового типа `Spaceship`.

4.3. Пример ad hoc полиморфизма
-------------------------------
- В `Main.demonstrateAdHocPolymorphism()` показана перегрузка метода `logAction(...)`: есть версии для `Spaceship`, для `CrewMember` и комбинированная для пары `Spaceship + Mission`.
- Компилятор выбирает нужный метод на этапе компиляции в зависимости от списка аргументов — это наглядный пример ad hoc полиморфизма (перегрузка по сигнатурам), отличающийся от динамического полиморфизма подтипов из п. 4.2.

